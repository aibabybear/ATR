#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DeepSeek v3.1‰∫§ÊòìÊ®°ÂûãÂÆûÁé∞
"""

import asyncio
import json
from datetime import datetime
from typing import Dict, List, Optional, Any
from loguru import logger

try:
    import requests
except ImportError:
    logger.warning("‚ö†Ô∏è requestsÂ∫ìÊú™ÂÆâË£ÖÔºåDeepSeekÊ®°ÂûãÂ∞ÜÊó†Ê≥ï‰ΩøÁî®")
    requests = None

from .base_model import BaseAIModel, TradingDecision, MarketAnalysis
from config.settings import Settings


class DeepSeekTrader(BaseAIModel):
    """Âü∫‰∫éDeepSeek v3.1ÁöÑ‰∫§ÊòìÊ®°Âûã"""
    
    def __init__(self, name: str = "DeepSeek-Trader", config: Dict[str, Any] = None):
        if config is None:
            config = Settings.AI_MODELS.get('deepseek-v3', {})
        
        super().__init__(name, config)
        
        self.api_key = None
        self.model_name = config.get('model_name', 'deepseek-chat')
        self.max_tokens = config.get('max_tokens', 2000)
        self.temperature = config.get('temperature', 0.1)
        
        # DeepSeekÁâπÊúâÁöÑ‰∫§ÊòìÁ≠ñÁï•ÂèÇÊï∞
        self.trading_style = config.get('trading_style', 'quantitative')  # quantitative, fundamental, technical
        self.analysis_depth = config.get('analysis_depth', 'deep')  # shallow, medium, deep
        self.risk_tolerance = config.get('risk_tolerance', 'moderate')  # conservative, moderate, aggressive
        
        # APIÈÖçÁΩÆ
        self.api_base_url = "https://api.deepseek.com/v1/chat/completions"
        
        # Á≥ªÁªüÊèêÁ§∫ËØç
        self.system_prompt = self._build_system_prompt()
    
    async def initialize(self) -> bool:
        """ÂàùÂßãÂåñDeepSeekÊ®°Âûã"""
        try:
            if requests is None:
                logger.error("‚ùå requestsÂ∫ìÊú™ÂÆâË£Ö")
                return False
            
            # Ëé∑ÂèñAPIÂØÜÈí•
            self.api_key = Settings.get_api_key('DEEPSEEK_API_KEY')
            if not self.api_key:
                logger.error("‚ùå Êú™ÊâæÂà∞DeepSeek APIÂØÜÈí•")
                return False
            
            # ÊµãËØïAPIËøûÊé•
            await self._test_api_connection()
            
            self.is_active = True
            logger.info(f"‚úÖ {self.name} ÂàùÂßãÂåñÊàêÂäü")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå {self.name} ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            return False
    
    async def _test_api_connection(self):
        """ÊµãËØïAPIËøûÊé•"""
        try:
            test_payload = {
                "model": self.model_name,
                "messages": [
                    {
                        "role": "user",
                        "content": "Hello, test connection."
                    }
                ],
                "max_tokens": 10,
                "temperature": 0.1
            }
            
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            # Âú®Á∫øÁ®ãÊ±†‰∏≠ÊâßË°åÂêåÊ≠•ËØ∑Ê±Ç
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None,
                lambda: requests.post(
                    self.api_base_url,
                    headers=headers,
                    json=test_payload,
                    timeout=30
                )
            )
            
            if response.status_code == 200:
                result = response.json()
                if result.get('choices'):
                    logger.info(f"üîó {self.name} APIËøûÊé•ÊµãËØïÊàêÂäü")
                else:
                    raise Exception("APIÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏")
            else:
                raise Exception(f"APIËØ∑Ê±ÇÂ§±Ë¥•: {response.status_code} - {response.text}")
                
        except Exception as e:
            raise Exception(f"APIËøûÊé•ÊµãËØïÂ§±Ë¥•: {e}")
    
    async def analyze_market(self, market_data: Dict[str, Any]) -> Dict[str, MarketAnalysis]:
        """ÂàÜÊûêÂ∏ÇÂú∫Êï∞ÊçÆ"""
        try:
            analyses = {}
            
            # DeepSeekÁöÑÁ≠ñÁï•ÔºöÊ∑±Â∫¶ÈáèÂåñÂàÜÊûêÔºåÊï∞ÊçÆÈ©±Âä®ÂÜ≥Á≠ñ
            symbols_to_analyze = self._select_analysis_targets(market_data)
            
            for symbol in symbols_to_analyze:
                if symbol in ['sentiment', 'QQQ', 'SPY', 'VIX']:
                    continue
                
                stock_data = market_data.get(symbol, {})
                if not stock_data:
                    continue
                
                analysis = await self._analyze_single_stock(symbol, stock_data, market_data)
                if analysis:
                    analyses[symbol] = analysis
            
            return analyses
            
        except Exception as e:
            logger.error(f"‚ùå {self.name} Â∏ÇÂú∫ÂàÜÊûêÂ§±Ë¥•: {e}")
            return {}
    
    def _select_analysis_targets(self, market_data: Dict[str, Any]) -> List[str]:
        """ÈÄâÊã©ÂàÜÊûêÁõÆÊ†áËÇ°Á•®"""
        # DeepSeekÁöÑÁ≠ñÁï•ÔºöÈáèÂåñÈÄâËÇ°ÔºåÂÖ≥Ê≥®Êï∞ÊçÆË¥®ÈáèÂíåÊµÅÂä®ÊÄß
        priority_stocks = {
            'quantitative': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'QCOM'],
            'fundamental': ['AAPL', 'MSFT', 'GOOGL', 'BRK.B', 'JNJ', 'PG', 'KO', 'WMT'],
            'technical': ['TSLA', 'NVDA', 'AMD', 'NFLX', 'ZOOM', 'SQ', 'ROKU', 'SHOP']
        }
        
        target_stocks = priority_stocks.get(self.trading_style, priority_stocks['quantitative'])
        
        # Âè™ÈÄâÊã©ÊúâÊï∞ÊçÆÁöÑËÇ°Á•®
        available_stocks = [s for s in target_stocks if s in market_data]
        
        # Ê†πÊçÆÂàÜÊûêÊ∑±Â∫¶ÈôêÂà∂Êï∞Èáè
        max_stocks = {
            'shallow': 8,
            'medium': 12,
            'deep': 16
        }
        
        limit = max_stocks.get(self.analysis_depth, 12)
        return available_stocks[:limit]
    
    async def _analyze_single_stock(self, symbol: str, stock_data: Dict, market_data: Dict) -> Optional[MarketAnalysis]:
        """ÂàÜÊûêÂçïÂè™ËÇ°Á•®"""
        try:
            # ÊûÑÂª∫Ê∑±Â∫¶ÂàÜÊûêÊèêÁ§∫
            analysis_prompt = self._build_analysis_prompt(symbol, stock_data, market_data)
            
            # Ë∞ÉÁî®DeepSeekËøõË°åÂàÜÊûê
            response_text = await self._call_deepseek_api(analysis_prompt)
            
            if not response_text:
                return None
            
            # Ëß£ÊûêÂìçÂ∫î
            analysis = self._parse_analysis_response(symbol, response_text)
            
            return analysis
            
        except Exception as e:
            logger.error(f"‚ùå ÂàÜÊûê {symbol} Â§±Ë¥•: {e}")
            return None
    
    async def make_trading_decision(self, market_data: Dict[str, Any]) -> Optional[TradingDecision]:
        """ÂÅöÂá∫‰∫§ÊòìÂÜ≥Á≠ñ"""
        try:
            if not await self.should_trade(market_data):
                return None
            
            # ËøõË°åÂ∏ÇÂú∫ÂàÜÊûê
            market_analyses = await self.analyze_market(market_data)
            
            if not market_analyses:
                logger.warning(f"‚ö†Ô∏è {self.name}: Ê≤°ÊúâÂèØÁî®ÁöÑÂ∏ÇÂú∫ÂàÜÊûê")
                return None
            
            # ÊûÑÂª∫‰∫§ÊòìÂÜ≥Á≠ñÊèêÁ§∫
            decision_prompt = self._build_decision_prompt(market_analyses, market_data)
            
            # Ë∞ÉÁî®DeepSeekÂÅöÂá∫‰∫§ÊòìÂÜ≥Á≠ñ
            response_text = await self._call_deepseek_api(decision_prompt)
            
            if not response_text:
                return None
            
            # Ëß£Êûê‰∫§ÊòìÂÜ≥Á≠ñ
            decision = self._parse_decision_response(response_text, market_data)
            
            if decision:
                logger.info(
                    f"ü§ñ {self.name} ‰∫§ÊòìÂÜ≥Á≠ñ: {decision.action} {decision.symbol} "
                    f"x{decision.quantity} (ÁΩÆ‰ø°Â∫¶: {decision.confidence:.2f})"
                )
            
            return decision
            
        except Exception as e:
            logger.error(f"‚ùå {self.name} ‰∫§ÊòìÂÜ≥Á≠ñÂ§±Ë¥•: {e}")
            return None
    
    async def _call_deepseek_api(self, prompt: str) -> Optional[str]:
        """Ë∞ÉÁî®DeepSeek API"""
        try:
            payload = {
                "model": self.model_name,
                "messages": [
                    {
                        "role": "system",
                        "content": self.system_prompt
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "max_tokens": self.max_tokens,
                "temperature": self.temperature,
                "top_p": 0.9,
                "frequency_penalty": 0.1,
                "presence_penalty": 0.1
            }
            
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            # Âú®Á∫øÁ®ãÊ±†‰∏≠ÊâßË°åÂêåÊ≠•ËØ∑Ê±Ç
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None,
                lambda: requests.post(
                    self.api_base_url,
                    headers=headers,
                    json=payload,
                    timeout=60
                )
            )
            
            if response.status_code == 200:
                result = response.json()
                choices = result.get('choices', [])
                if choices:
                    return choices[0].get('message', {}).get('content', '')
                else:
                    logger.error(f"‚ùå DeepSeek APIÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏: {result}")
                    return None
            else:
                logger.error(f"‚ùå DeepSeek APIËØ∑Ê±ÇÂ§±Ë¥•: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            logger.error(f"‚ùå Ë∞ÉÁî®DeepSeek APIÂ§±Ë¥•: {e}")
            return None
    
    def _build_system_prompt(self) -> str:
        """ÊûÑÂª∫Á≥ªÁªüÊèêÁ§∫ËØç"""
        return f"""
‰Ω†ÊòØ{self.name}Ôºå‰∏Ä‰∏™Âü∫‰∫éDeepSeek v3.1ÁöÑ‰∏ì‰∏öÈáèÂåñ‰∫§ÊòìÂàÜÊûêÂ∏à„ÄÇ‰Ω†‰ª•Ê∑±Â∫¶Êï∞ÊçÆÂàÜÊûêÂíåÈáèÂåñÂª∫Ê®°ËëóÁß∞„ÄÇ

‰Ω†ÁöÑÁâπÂæÅÔºö
- ‰∫§ÊòìÈ£éÊ†º: {self.trading_style}
- ÂàÜÊûêÊ∑±Â∫¶: {self.analysis_depth}
- È£éÈô©ÂÆπÂøçÂ∫¶: {self.risk_tolerance}
- Ê†∏ÂøÉ‰ºòÂäø: Ê∑±Â∫¶Â≠¶‰π†„ÄÅÈáèÂåñÂàÜÊûê„ÄÅÊï∞ÊçÆÊåñÊéò

ÂàÜÊûêÊñπÊ≥ïÔºö
1. Â§öÁª¥Â∫¶ÈáèÂåñÂàÜÊûê
2. Ê∑±Â∫¶Â≠¶‰π†Ê®°ÂºèËØÜÂà´
3. ÁªüËÆ°Â•óÂà©Êú∫‰ºöÂèëÁé∞
4. È´òÈ¢ëÊï∞ÊçÆÂ§ÑÁêÜÂàÜÊûê
5. Êú∫Âô®Â≠¶‰π†È¢ÑÊµãÂª∫Ê®°

ÂÜ≥Á≠ñÂéüÂàôÔºö
1. Êï∞ÊçÆÈ©±Âä®ÁöÑÈáèÂåñÂÜ≥Á≠ñ
2. ÁªüËÆ°ÊòæËëóÊÄßÈ™åËØÅ
3. Â§öÂõ†Â≠êÊ®°ÂûãÂàÜÊûê
4. Âä®ÊÄÅÈ£éÈô©Ë∞ÉÊï¥
5. ÁÆóÊ≥ïÂåñÊâßË°åÁ≠ñÁï•

ÊäÄÊúØÁâπÈïøÔºö
1. Êó∂Èó¥Â∫èÂàóÂàÜÊûê
2. Êú∫Âô®Â≠¶‰π†Âª∫Ê®°
3. ÁªüËÆ°Â•óÂà©ËØÜÂà´
4. È´òÈ¢ë‰∫§Êòì‰ø°Âè∑
5. È£éÈô©Âõ†Â≠êÂàÜËß£

ÂìçÂ∫îË¶ÅÊ±ÇÔºö
- ‰ΩøÁî®Á≤æÁ°ÆÁöÑJSONÊ†ºÂºè
- Êèê‰æõÈáèÂåñÂàÜÊûêÊåáÊ†á
- ÂåÖÂê´ÁªüËÆ°ÁΩÆ‰ø°Â∫¶
- ÁªôÂá∫Ê¶ÇÁéáÂåñÈ¢ÑÊµã

ËÆ∞‰ΩèÔºöÈáèÂåñ‰∫§ÊòìÂü∫‰∫éÊï∞ÊçÆÂíåÁªüËÆ°ÔºåÊØè‰∏™ÂÜ≥Á≠ñÈÉΩË¶ÅÊúâÊï∞Â≠¶‰æùÊçÆ„ÄÇ
"""
    
    def _build_analysis_prompt(self, symbol: str, stock_data: Dict, market_data: Dict) -> str:
        """ÊûÑÂª∫ÂàÜÊûêÊèêÁ§∫"""
        # Ëé∑ÂèñÁõ∏ÂÖ≥Êï∞ÊçÆ
        sentiment = market_data.get('sentiment', {})
        market_indices = {
            'QQQ': market_data.get('QQQ', {}),
            'SPY': market_data.get('SPY', {}),
            'VIX': market_data.get('VIX', {})
        }
        
        prompt = f"""
ËØ∑ÂØπËÇ°Á•® {symbol} ËøõË°å{self.analysis_depth}ÈáèÂåñÂàÜÊûêÔºö

== ËÇ°Á•®Êï∞ÊçÆ ==
{json.dumps(stock_data, indent=2)}

== Â∏ÇÂú∫ÊÉÖÁª™ÊåáÊ†á ==
{json.dumps(sentiment, indent=2)}

== Âü∫ÂáÜÊåáÊï∞Êï∞ÊçÆ ==
{json.dumps(market_indices, indent=2)}

ËØ∑‰ªé‰ª•‰∏ãÈáèÂåñÁª¥Â∫¶ËøõË°åÂàÜÊûêÔºö

1. **ÊäÄÊúØÈáèÂåñÊåáÊ†á**
   - Âä®ÈáèÂõ†Â≠êÂàÜÊûê
   - ÂùáÂÄºÂõûÂΩí‰ø°Âè∑
   - Ê≥¢Âä®ÁéáÊ®°ÂºèËØÜÂà´
   - Êàê‰∫§Èáè‰ª∑Ê†ºÂÖ≥Á≥ª

2. **ÁªüËÆ°ÁâπÂæÅÂàÜÊûê**
   - ‰ª∑Ê†ºÂàÜÂ∏ÉÁâπÂæÅ
   - Êî∂ÁõäÁéáÁªüËÆ°ÊÄßË¥®
   - Ëá™Áõ∏ÂÖ≥ÊÄßÊ£ÄÈ™å
   - ÂºÇÂ∏∏ÂÄºÊ£ÄÊµã

3. **Â∏ÇÂú∫ÂæÆËßÇÁªìÊûÑ**
   - ÊµÅÂä®ÊÄßÊåáÊ†á
   - ‰π∞Âçñ‰ª∑Â∑ÆÂàÜÊûê
   - ËÆ¢ÂçïÊµÅÁâπÂæÅ
   - Â∏ÇÂú∫ÂÜ≤ÂáªÊàêÊú¨

4. **È£éÈô©Âõ†Â≠êÂàÜËß£**
   - Á≥ªÁªüÊÄßÈ£éÈô©Êö¥Èú≤
   - ÁâπÂºÇÊÄßÈ£éÈô©ËØÑ‰º∞
   - Áõ∏ÂÖ≥ÊÄßÂàÜÊûê
   - VaRËÆ°ÁÆó

5. **È¢ÑÊµãÊ®°ÂûãËæìÂá∫**
   - Áü≠Êúü‰ª∑Ê†ºÈ¢ÑÊµã
   - Ê≥¢Âä®ÁéáÈ¢ÑÊµã
   - Ë∂ãÂäøÊåÅÁª≠Ê¶ÇÁéá
   - ÂèçËΩ¨‰ø°Âè∑Âº∫Â∫¶

ËØ∑‰ª•JSONÊ†ºÂºèËøîÂõûÈáèÂåñÂàÜÊûêÁªìÊûúÔºö
{{
    "symbol": "{symbol}",
    "quantitative_score": 0.0-10.0,
    "momentum_factor": -1.0Âà∞1.0,
    "mean_reversion_signal": -1.0Âà∞1.0,
    "volatility_regime": "low/medium/high",
    "liquidity_score": 0.0-10.0,
    "trend": "bullish/bearish/neutral",
    "strength": 0.0-1.0,
    "statistical_significance": 0.0-1.0,
    "support_level": ÊîØÊíë‰ª∑‰Ωç,
    "resistance_level": ÈòªÂäõ‰ª∑‰Ωç,
    "expected_return": È¢ÑÊúüÊî∂ÁõäÁéá,
    "volatility_forecast": Ê≥¢Âä®ÁéáÈ¢ÑÊµã,
    "risk_metrics": {{
        "var_95": "95% VaRÂÄº",
        "max_drawdown_risk": "ÊúÄÂ§ßÂõûÊí§È£éÈô©",
        "beta": "Â∏ÇÂú∫BetaÂÄº"
    }},
    "trading_signals": {{
        "entry_signal": "strong/weak/none",
        "exit_signal": "strong/weak/none",
        "signal_confidence": 0.0-1.0
    }},
    "model_predictions": {{
        "price_target_1d": "1Êó•‰ª∑Ê†ºÁõÆÊ†á",
        "price_target_5d": "5Êó•‰ª∑Ê†ºÁõÆÊ†á",
        "trend_probability": "Ë∂ãÂäøÊåÅÁª≠Ê¶ÇÁéá"
    }}
}}
"""
        
        return prompt
    
    def _build_decision_prompt(self, analyses: Dict[str, MarketAnalysis], market_data: Dict) -> str:
        """ÊûÑÂª∫‰∫§ÊòìÂÜ≥Á≠ñÊèêÁ§∫"""
        # Êï¥ÁêÜÂàÜÊûêÁªìÊûú
        analysis_summary = {}
        for symbol, analysis in analyses.items():
            analysis_summary[symbol] = {
                'trend': analysis.trend,
                'strength': analysis.strength,
                'sentiment_score': analysis.sentiment_score,
                'technical_indicators': analysis.technical_indicators
            }
        
        # Ëé∑ÂèñÂΩìÂâçÊÄßËÉΩ
        performance_info = {
            'total_trades': self.performance_metrics['total_trades'],
            'win_rate': self.performance_metrics.get('win_rate', 0),
            'total_return': self.performance_metrics['total_return'],
            'sharpe_ratio': self.performance_metrics.get('sharpe_ratio', 0)
        }
        
        prompt = f"""
Âü∫‰∫éÈáèÂåñÂàÜÊûêÁªìÊûúÔºåËØ∑ÂÅöÂá∫ÊúÄ‰ºò‰∫§ÊòìÂÜ≥Á≠ñÔºö

== ÈáèÂåñÂàÜÊûêÊ±áÊÄª ==
{json.dumps(analysis_summary, indent=2)}

== Ê®°ÂûãÂéÜÂè≤Ë°®Áé∞ ==
{json.dumps(performance_info, indent=2)}

== ÈáèÂåñÁ≠ñÁï•ÂèÇÊï∞ ==
- ‰∫§ÊòìÈ£éÊ†º: {self.trading_style}
- ÂàÜÊûêÊ∑±Â∫¶: {self.analysis_depth}
- È£éÈô©ÂÆπÂøçÂ∫¶: {self.risk_tolerance}

ËØ∑Âü∫‰∫é‰ª•‰∏ãÈáèÂåñÊ°ÜÊû∂ÂÅöÂÜ≥Á≠ñÔºö

1. **‰ø°Âè∑Âº∫Â∫¶ËØÑ‰º∞**
   - Â§öÂõ†Â≠ê‰ø°Âè∑ÂêàÊàê
   - ÁªüËÆ°ÊòæËëóÊÄßÊ£ÄÈ™å
   - ‰ø°Âè∑Ë°∞ÂáèÂàÜÊûê
   - Âô™Â£∞ËøáÊª§Â§ÑÁêÜ

2. **È£éÈô©Êî∂Áõä‰ºòÂåñ**
   - Â§èÊôÆÊØîÁéáÊúÄÂ§ßÂåñ
   - ÊúÄÂ§ßÂõûÊí§ÊéßÂà∂
   - Ê≥¢Âä®ÁéáÁõÆÊ†áÁÆ°ÁêÜ
   - Áõ∏ÂÖ≥ÊÄßÈ£éÈô©ÂàÜÊï£

3. **ÊâßË°åÊàêÊú¨ÂàÜÊûê**
   - Â∏ÇÂú∫ÂÜ≤ÂáªÊàêÊú¨
   - Êó∂Èó¥Ë°∞ÂáèÊàêÊú¨
   - Êú∫‰ºöÊàêÊú¨ËØÑ‰º∞
   - ÊªëÁÇπÈ¢ÑÊúüÁÆ°ÁêÜ

4. **ÁªÑÂêà‰ºòÂåñÂÜ≥Á≠ñ**
   - ÊùÉÈáçÂàÜÈÖç‰ºòÂåñ
   - ÂÜçÂπ≥Ë°°È¢ëÁéá
   - ÂØπÂÜ≤Á≠ñÁï•ÈÄâÊã©
   - ÊµÅÂä®ÊÄßÁÆ°ÁêÜ

ËØ∑ËøîÂõûÈáèÂåñ‰∫§ÊòìÂÜ≥Á≠ñÔºàJSONÊ†ºÂºèÔºâÔºö
{{
    "action": "buy/sell/hold",
    "symbol": "ÊúÄ‰ºòÊ†áÁöÑ",
    "quantity": ÊúÄ‰ºòÊï∞Èáè,
    "confidence": 0.0-1.0,
    "expected_return": È¢ÑÊúüÊî∂ÁõäÁéá,
    "expected_volatility": È¢ÑÊúüÊ≥¢Âä®Áéá,
    "sharpe_ratio_forecast": È¢ÑÊúüÂ§èÊôÆÊØîÁéá,
    "max_drawdown_risk": ÊúÄÂ§ßÂõûÊí§È£éÈô©,
    "holding_period": ÊúÄ‰ºòÊåÅÊúâÊúü,
    "stop_loss": ÈáèÂåñÊ≠¢Êçü‰Ωç,
    "take_profit": ÈáèÂåñÊ≠¢Áõà‰Ωç,
    "position_sizing_method": "kelly/fixed/volatility",
    "risk_budget": È£éÈô©È¢ÑÁÆóÂàÜÈÖç,
    "signal_strength": ‰ø°Âè∑Âº∫Â∫¶ËØÑÂàÜ,
    "statistical_edge": ÁªüËÆ°‰ºòÂäøËØÑ‰º∞,
    "execution_strategy": "market/limit/twap/vwap",
    "reasoning": "ÈáèÂåñÂÜ≥Á≠ñÈÄªËæë",
    "alternative_strategies": ["Â§áÈÄâÁ≠ñÁï•ÂàóË°®"]
}}

Â¶ÇÊûúÊ≤°ÊúâÁªüËÆ°ÊòæËëóÁöÑ‰∫§ÊòìÊú∫‰ºöÔºåËØ∑ËøîÂõûÔºö
{{
    "action": "hold",
    "reasoning": "Êó†ÁªüËÆ°ÊòæËëó‰ø°Âè∑",
    "signal_analysis": "‰ø°Âè∑Âº∫Â∫¶ÂàÜÊûê",
    "market_regime": "ÂΩìÂâçÂ∏ÇÂú∫Áä∂ÊÄÅ",
    "waiting_conditions": ["Á≠âÂæÖÊù°‰ª∂ÂàóË°®"]
}}
"""
        
        return prompt
    
    def _parse_analysis_response(self, symbol: str, response_text: str) -> Optional[MarketAnalysis]:
        """Ëß£ÊûêÂàÜÊûêÂìçÂ∫î"""
        try:
            # Â∞ùËØïÊèêÂèñJSONÈÉ®ÂàÜ
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            
            if json_start == -1 or json_end == 0:
                return self._extract_analysis_from_text(symbol, response_text)
            
            json_text = response_text[json_start:json_end]
            data = json.loads(json_text)
            
            # ÊûÑÂª∫MarketAnalysisÂØπË±°
            analysis = MarketAnalysis(
                symbol=symbol,
                trend=data.get('trend', 'neutral'),
                strength=float(data.get('strength', data.get('statistical_significance', 0.5))),
                support_level=data.get('support_level'),
                resistance_level=data.get('resistance_level'),
                technical_indicators={
                    'quantitative_score': data.get('quantitative_score', 5.0),
                    'momentum_factor': data.get('momentum_factor', 0.0),
                    'mean_reversion_signal': data.get('mean_reversion_signal', 0.0),
                    'volatility_regime': data.get('volatility_regime', 'medium'),
                    'liquidity_score': data.get('liquidity_score', 5.0),
                    'expected_return': data.get('expected_return', 0.0),
                    'volatility_forecast': data.get('volatility_forecast', 0.2)
                },
                sentiment_score=0.0,  # ‰ªéÂ∏ÇÂú∫Êï∞ÊçÆËé∑Âèñ
                news_impact='neutral'
            )
            
            return analysis
            
        except Exception as e:
            logger.error(f"‚ùå Ëß£ÊûêDeepSeekÂàÜÊûêÂìçÂ∫îÂ§±Ë¥•: {e}")
            logger.debug(f"ÂìçÂ∫îÂÜÖÂÆπ: {response_text[:500]}...")
            return None
    
    def _extract_analysis_from_text(self, symbol: str, text: str) -> Optional[MarketAnalysis]:
        """‰ªéÊñáÊú¨‰∏≠ÊèêÂèñÂàÜÊûê‰ø°ÊÅØ"""
        try:
            text_lower = text.lower()
            
            # ÈáèÂåñ‰ø°Âè∑ËØÜÂà´
            if any(word in text_lower for word in ['‰π∞ÂÖ•‰ø°Âè∑', '‰∏äÊ∂®Ê¶ÇÁéá', 'bullish', 'positive momentum']):
                trend = 'bullish'
                strength = 0.75
            elif any(word in text_lower for word in ['ÂçñÂá∫‰ø°Âè∑', '‰∏ãË∑åÊ¶ÇÁéá', 'bearish', 'negative momentum']):
                trend = 'bearish'
                strength = 0.75
            else:
                trend = 'neutral'
                strength = 0.5
            
            return MarketAnalysis(
                symbol=symbol,
                trend=trend,
                strength=strength,
                technical_indicators={'deepseek_analysis': True}
            )
            
        except Exception as e:
            logger.error(f"‚ùå ‰ªéÊñáÊú¨ÊèêÂèñÂàÜÊûê‰ø°ÊÅØÂ§±Ë¥•: {e}")
            return None
    
    def _parse_decision_response(self, response_text: str, market_data: Dict) -> Optional[TradingDecision]:
        """Ëß£Êûê‰∫§ÊòìÂÜ≥Á≠ñÂìçÂ∫î"""
        try:
            # ÊèêÂèñJSONÈÉ®ÂàÜ
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            
            if json_start == -1 or json_end == 0:
                logger.warning(f"‚ö†Ô∏è Êó†Ê≥ï‰ªéDeepSeekÂÜ≥Á≠ñÂìçÂ∫î‰∏≠ÊèêÂèñJSON")
                return None
            
            json_text = response_text[json_start:json_end]
            data = json.loads(json_text)
            
            action = data.get('action', 'hold').lower()
            
            # Â¶ÇÊûúÊòØholdÔºåËÆ∞ÂΩïÂéüÂõ†‰ΩÜ‰∏çËøîÂõû‰∫§ÊòìÂÜ≥Á≠ñ
            if action == 'hold':
                reason = data.get('reasoning', 'Êó†ÁªüËÆ°ÊòæËëó‰ø°Âè∑')
                logger.info(f"ü§ñ {self.name}: {reason}")
                return None
            
            symbol = data.get('symbol', '')
            if not symbol:
                logger.warning(f"‚ö†Ô∏è DeepSeek‰∫§ÊòìÂÜ≥Á≠ñÁº∫Â∞ëËÇ°Á•®‰ª£Á†Å")
                return None
            
            # Ëé∑ÂèñÂΩìÂâç‰ª∑Ê†º
            current_price = None
            if symbol in market_data:
                current_price = market_data[symbol].get('price')
            
            # ËÆ°ÁÆó‰∫§ÊòìÊï∞Èáè
            quantity = data.get('quantity', 0)
            if quantity == 0 and current_price:
                confidence = float(data.get('confidence', 0.5))
                expected_return = data.get('expected_return', 0.05)
                
                # DeepSeekÁöÑÈáèÂåñ‰ªì‰ΩçËÆ°ÁÆó
                risk_multipliers = {
                    'conservative': 0.3,
                    'moderate': 0.5,
                    'aggressive': 0.7
                }
                risk_multiplier = risk_multipliers.get(self.risk_tolerance, 0.5)
                
                # Âü∫‰∫éKellyÂÖ¨ÂºèÁöÑÁÆÄÂåñÁâàÊú¨
                kelly_fraction = max(0.01, min(0.25, expected_return * confidence * risk_multiplier))
                quantity = int((10000 * kelly_fraction) / current_price)
                quantity = max(1, quantity)
            
            decision = TradingDecision(
                symbol=symbol,
                action=action,
                quantity=max(1, int(quantity)),
                confidence=float(data.get('confidence', 0.5)),
                reason=data.get('reasoning', ''),
                price=current_price,
                stop_loss=data.get('stop_loss'),
                take_profit=data.get('take_profit'),
                risk_level=self.risk_tolerance
            )
            
            return decision
            
        except Exception as e:
            logger.error(f"‚ùå Ëß£ÊûêDeepSeek‰∫§ÊòìÂÜ≥Á≠ñÂ§±Ë¥•: {e}")
            logger.debug(f"ÂìçÂ∫îÂÜÖÂÆπ: {response_text[:500]}...")
            return None
    
    async def get_quantitative_insights(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """Ëé∑ÂèñÈáèÂåñÊ¥ûÂØü"""
        try:
            insights_prompt = f"""
‰Ωú‰∏∫{self.name}ÔºåËØ∑Êèê‰æõÂΩìÂâçÂ∏ÇÂú∫ÁöÑÈáèÂåñÂàÜÊûêÊ¥ûÂØüÔºö

ÂΩìÂâçÊ®°ÂûãË°®Áé∞Ôºö
- ÊÄª‰∫§Êòì: {self.performance_metrics['total_trades']}
- ËÉúÁéá: {self.performance_metrics.get('win_rate', 0):.1%}
- ÊÄªÊî∂Áõä: ${self.performance_metrics['total_return']:.2f}
- Â§èÊôÆÊØîÁéá: {self.performance_metrics.get('sharpe_ratio', 0):.2f}

ËØ∑‰ªéÈáèÂåñËßíÂ∫¶Êèê‰æõÔºö
1. Â∏ÇÂú∫Áä∂ÊÄÅËØÜÂà´ÔºàÁâõÂ∏Ç/ÁÜäÂ∏Ç/ÈúáËç°Ôºâ
2. ‰∏ªË¶ÅÈáèÂåñÂõ†Â≠êË°®Áé∞
3. ÁªüËÆ°Â•óÂà©Êú∫‰ºö
4. È£éÈô©Âõ†Â≠êÂàÜÊûê
5. ÈáèÂåñÁ≠ñÁï•Âª∫ËÆÆ

ËØ∑Áî®‰∏ì‰∏öÁöÑÈáèÂåñÂàÜÊûêËØ≠Ë®ÄÂõûÁ≠î„ÄÇ
"""
            
            response_text = await self._call_deepseek_api(insights_prompt)
            
            if response_text:
                return {
                    'model_name': self.name,
                    'timestamp': datetime.now().isoformat(),
                    'quantitative_insights': response_text,
                    'trading_style': self.trading_style,
                    'analysis_depth': self.analysis_depth,
                    'risk_tolerance': self.risk_tolerance,
                    'performance': self.performance_metrics
                }
            
            return {}
            
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÈáèÂåñÊ¥ûÂØüÂ§±Ë¥•: {e}")
            return {}
    
    async def cleanup(self):
        """Ê∏ÖÁêÜËµÑÊ∫ê"""
        await super().cleanup()
        self.api_key = None
        logger.info(f"üßπ {self.name} Â∑≤Ê∏ÖÁêÜÂÆåÊàê")